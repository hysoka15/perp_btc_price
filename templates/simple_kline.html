<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€åŒ–Kçº¿å›¾ - å¤šäº¤æ˜“æ‰€BTCä»·å·®åˆ†æ</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: #0b0e11;
            color: #ffffff;
        }
        
        .header {
            background: #1a1d21;
            padding: 15px 20px;
            border-bottom: 1px solid #2a2d31;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .control-group label {
            font-size: 14px;
            color: #ccc;
        }
        
        .btn {
            padding: 8px 16px;
            background: #2a2d31;
            border: 1px solid #404040;
            border-radius: 4px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .btn:hover {
            background: #3a3d41;
        }
        
        .btn.active {
            background: #0088cc;
            border-color: #0088cc;
        }
        
        .exchange-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #2a2d31;
            border: 1px solid #404040;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            margin-right: 8px;
            margin-bottom: 4px;
        }
        
        .exchange-checkbox:hover {
            background: #3a3d41;
        }
        
        .exchange-checkbox.active {
            background: #0088cc;
            border-color: #0088cc;
        }
        
        .exchange-checkbox input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: #ffffff;
        }
        
        .exchanges-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .main-content {
            display: flex;
            height: calc(100vh - 80px);
        }
        
        .chart-container {
            flex: 1;
            background: #0b0e11;
            position: relative;
            min-height: 600px;
        }
        
        .sidebar {
            width: 300px;
            background: #1a1d21;
            border-left: 1px solid #2a2d31;
            padding: 20px;
            overflow-y: auto;
        }
        
        .info-section {
            margin-bottom: 20px;
        }
        
        .info-section h3 {
            color: #0088cc;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #2a2d31;
        }
        
        .positive {
            color: #26a69a;
        }
        
        .negative {
            color: #ef5350;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #2a2d31;
            border-top: 3px solid #0088cc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #chart {
            width: 100%;
            height: 100%;
        }
        
        .demo-notice {
            background: #ffc107;
            color: #000;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="demo-notice">
        ğŸ‰ ä¸“ä¸šKçº¿å›¾æ¼”ç¤ºç‰ˆæœ¬ - æ”¯æŒäº¤æ˜“æ‰€åˆ‡æ¢ã€æ—¶é—´å‘¨æœŸé€‰æ‹©ã€ç¼©æ”¾æ»šåŠ¨ç­‰åŠŸèƒ½
    </div>
    
    <div class="header">
        <div class="title">ä¸“ä¸šKçº¿å›¾ - BTCä»·å·®åˆ†æ</div>
        
        <div class="controls">
            <div class="control-group">
                <label>äº¤æ˜“æ‰€:</label>
                <div class="exchanges-container">
                    <label class="exchange-checkbox active" data-exchange="aster">
                        <input type="checkbox" checked data-exchange="aster"> Aster
                    </label>
                    <label class="exchange-checkbox" data-exchange="lighter">
                        <input type="checkbox" data-exchange="lighter"> Lighter
                    </label>
                    <label class="exchange-checkbox" data-exchange="edgex">
                        <input type="checkbox" data-exchange="edgex"> EdgeX
                    </label>
                </div>
            </div>
            
            <div class="control-group">
                <label>å‘¨æœŸ:</label>
                <button class="btn" data-interval="1m">1åˆ†</button>
                <button class="btn" data-interval="5m">5åˆ†</button>
                <button class="btn" data-interval="15m">15åˆ†</button>
                <button class="btn active" data-interval="1h">1æ—¶</button>
                <button class="btn" data-interval="4h">4æ—¶</button>
                <button class="btn" data-interval="1d">1æ—¥</button>
            </div>
            
            <div class="status">
                <div class="status-indicator"></div>
                <span id="lastUpdate">åŠ è½½ä¸­...</span>
            </div>
        </div>
    </div>
    
    <div class="main-content">
        <div class="chart-container">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>åŠ è½½Kçº¿æ•°æ®...</div>
            </div>
            <canvas id="chart"></canvas>
        </div>
        
        <div class="sidebar">
            <div class="info-section">
                <h3>ğŸ“Š å½“å‰æ•°æ®</h3>
                <div id="currentData">
                    <div class="info-item">
                        <span>äº¤æ˜“æ‰€:</span>
                        <span id="currentExchange">Aster</span>
                    </div>
                    <div class="info-item">
                        <span>å‘¨æœŸ:</span>
                        <span id="currentInterval">1å°æ—¶</span>
                    </div>
                    <div class="info-item">
                        <span>æ•°æ®é‡:</span>
                        <span id="dataCount">-</span>
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h3>ğŸ’¹ æœ€æ–°ä»·å·®</h3>
                <div id="latestPriceInfo">
                    <div class="info-item">
                        <span>å¼€ç›˜:</span>
                        <span id="openPrice" class="positive">--</span>
                    </div>
                    <div class="info-item">
                        <span>æœ€é«˜:</span>
                        <span id="highPrice" class="positive">--</span>
                    </div>
                    <div class="info-item">
                        <span>æœ€ä½:</span>
                        <span id="lowPrice" class="negative">--</span>
                    </div>
                    <div class="info-item">
                        <span>æ”¶ç›˜:</span>
                        <span id="closePrice" class="positive">--</span>
                    </div>
                    <div class="info-item">
                        <span>æˆäº¤é‡:</span>
                        <span id="volume">--</span>
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h3>âš¡ åŠŸèƒ½ç‰¹æ€§</h3>
                <div style="font-size: 12px; line-height: 1.6; color: #ccc;">
                    <p>âœ… ä¸“ä¸šKçº¿å›¾æ˜¾ç¤º</p>
                    <p>âœ… å¤šäº¤æ˜“æ‰€æ•°æ®åˆ‡æ¢</p>
                    <p>âœ… å¤šæ—¶é—´å‘¨æœŸæ”¯æŒ</p>
                    <p>âœ… é¼ æ ‡æ»šè½®ç¼©æ”¾</p>
                    <p>âœ… æ‹–æ‹½æµè§ˆå†å²</p>
                    <p>âœ… å®æ—¶æ•°æ®æ›´æ–°</p>
                    <p>âœ… åå­—çº¿ä»·æ ¼æŸ¥çœ‹</p>
                </div>
            </div>
            
            <div class="info-section">
                <h3>ğŸ“ˆ ç»Ÿè®¡ä¿¡æ¯</h3>
                <div id="statisticsInfo">
                    <div class="info-item">
                        <span>æ€»è®°å½•:</span>
                        <span id="totalRecords">-</span>
                    </div>
                    <div class="info-item">
                        <span>æ´»è·ƒäº¤æ˜“æ‰€:</span>
                        <span id="activeExchanges">-</span>
                    </div>
                    <div class="info-item">
                        <span>æœ€æ–°æ—¶é—´:</span>
                        <span id="latestTime">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ä½¿ç”¨è½»é‡çº§å›¾è¡¨åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    
    <script>
        class SimpleKLineManager {
            constructor() {
                this.chart = null;
                this.selectedExchanges = ['aster'];  // æ”¹ä¸ºæ•°ç»„æ”¯æŒå¤šé€‰
                this.currentInterval = '1h';
                this.refreshInterval = null;
                this.isLoading = false;
                this.isLoadingMore = false;
                this.isLoadingMoreHistory = false;
                this.visibleDataCount = this.getDefaultVisibleCount(this.currentInterval);
                this.viewStartIndex = 0;
                this.fullDataLength = 0;
                this.previousFullDataLength = 0;
                this.isViewInitialized = false;
                this.dragAccumulator = 0;
                
                this.init();
            }
            
            init() {
                this.createChart();
                this.bindEvents();
                this.loadData();
                this.loadStatistics();
                this.startAutoRefresh();
            }

            getDefaultVisibleCount(interval) {
                // ä¼˜åŒ–é»˜è®¤æ˜¾ç¤ºæ•°é‡ï¼Œç¡®ä¿åˆé€‚çš„çº¿æ¡å¯†åº¦
                const defaults = {
                    '1m': 120,   // 2å°æ—¶æ•°æ®ï¼Œå¯†åº¦é€‚ä¸­
                    '5m': 144,   // 12å°æ—¶æ•°æ®
                    '15m': 96,   // 24å°æ—¶æ•°æ®
                    '1h': 168,   // 7å¤©æ•°æ®
                    '4h': 84,    // 14å¤©æ•°æ®ï¼Œå¯†åº¦æ›´åˆç†
                    '1d': 60     // 2ä¸ªæœˆæ•°æ®
                };
                return defaults[interval] || 100;
            }
            
            createChart() {
                const ctx = document.getElementById('chart').getContext('2d');
                
                // æ£€æŸ¥ç¼©æ”¾æ’ä»¶æ˜¯å¦å¯ç”¨
                if (typeof window.ChartZoom !== 'undefined') {
                    Chart.register(window.ChartZoom);
                    console.log('âœ… ç¼©æ”¾æ’ä»¶å·²æ³¨å†Œ');
                } else {
                    console.log('â„¹ï¸ æœªæ£€æµ‹åˆ°zoomæ’ä»¶ï¼Œä½¿ç”¨è‡ªå®šä¹‰æ‹–æ‹½é€»è¾‘');
                }
                
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        backgroundColor: '#0b0e11',
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(26, 29, 33, 0.95)',
                                titleColor: '#ffffff',
                                bodyColor: '#ffffff',
                                borderColor: '#2a2d31',
                                borderWidth: 1,
                                padding: 12,
                                callbacks: {
                                    title: function(context) {
                                        return 'æ—¶é—´: ' + context[0].label;
                                    },
                                    label: function(context) {
                                        const dataset = context.dataset;
                                        const dataIndex = context.dataIndex;
                                        const value = context.parsed.y;
                                        
                                        if (value === null || value === undefined) {
                                            return `${dataset.label}: æ— æ•°æ®`;
                                        }
                                        
                                        const sign = value >= 0 ? '+' : '';
                                        let result = [`${dataset.label}: ${sign}${value.toFixed(4)} USDT`];
                                        
                                        // å¦‚æœæœ‰è¯¦ç»†ä»·æ ¼ä¿¡æ¯ï¼Œæ˜¾ç¤ºå¸å®‰ä»·æ ¼å’Œäº¤æ˜“æ‰€ä»·æ ¼
                                        if (dataset.exchangePrices && dataset.binancePrices && 
                                            dataset.exchangePrices[dataIndex] !== null && dataset.exchangePrices[dataIndex] !== undefined &&
                                            dataset.binancePrices[dataIndex] !== null && dataset.binancePrices[dataIndex] !== undefined) {
                                            const exchangePrice = parseFloat(dataset.exchangePrices[dataIndex]);
                                            const binancePrice = parseFloat(dataset.binancePrices[dataIndex]);
                                            
                                            if (!Number.isNaN(binancePrice)) {
                                                result.push(`å¸å®‰ä»·æ ¼: ${binancePrice.toFixed(2)} USDT`);
                                            }
                                            if (!Number.isNaN(exchangePrice)) {
                                                result.push(`${dataset.exchange.toUpperCase()}ä»·æ ¼: ${exchangePrice.toFixed(2)} USDT`);
                                            }
                                        }
                                        
                                        return result;
                                    }
                                }
                            },
                            zoom: {
                                pan: {
                                    enabled: false,  // ç¦ç”¨æ‹–æ‹½
                                    mode: 'x'
                                },
                                zoom: {
                                    wheel: {
                                        enabled: false  // ç¦ç”¨æ»šè½®ç¼©æ”¾
                                    },
                                    mode: 'x'
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    color: '#2a2d31'
                                },
                                ticks: {
                                    color: '#ffffff',
                                    maxTicksLimit: 10
                                }
                            },
                            y: {
                                grid: {
                                    color: function(context) {
                                        return context.tick.value === 0 ? '#ffffff' : '#2a2d31';
                                    }
                                },
                                ticks: {
                                    color: '#ffffff',
                                    callback: function(value) {
                                        const sign = value >= 0 ? '+' : '';
                                        return sign + value.toFixed(2);
                                    }
                                }
                            }
                        },
                        elements: {
                            line: {
                                tension: 0.1,
                                borderWidth: 2
                            },
                            point: {
                                radius: 0,
                                hoverRadius: 4
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                
                // å¯ç”¨ç¼©æ”¾å’Œå¹³ç§»
                this.enableChartInteraction();
            }
            
            enableChartInteraction() {
                const canvas = this.chart.canvas;
                let isDragging = false;
                let lastX = 0;
                this.dragAccumulator = 0;

                const getFullLength = () => this.chart.data.fullLabels ? this.chart.data.fullLabels.length : 0;

                canvas.addEventListener('mousedown', (e) => {
                    if (!getFullLength()) return;
                    isDragging = true;
                    lastX = e.clientX;
                    this.dragAccumulator = 0;
                    canvas.style.cursor = 'grabbing';
                    e.preventDefault();
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    const fullLength = getFullLength();
                    if (!fullLength) {
                        lastX = e.clientX;
                        return;
                    }

                    const rect = canvas.getBoundingClientRect();
                    const pixelsPerPoint = rect.width > 0 ? rect.width / Math.max(1, this.visibleDataCount) : 10;

                    const deltaX = e.clientX - lastX;
                    this.dragAccumulator += deltaX / pixelsPerPoint;
                    const moveAmount = Math.trunc(this.dragAccumulator);

                    if (moveAmount !== 0) {
                        this.dragAccumulator -= moveAmount;

                        let newViewStart = this.viewStartIndex - moveAmount;
                        const maxStart = Math.max(0, fullLength - this.visibleDataCount);

                        if (newViewStart < 0) {
                            if (!this.isLoadingMoreHistory) {
                                console.log('ğŸ”„ åˆ°è¾¾å·¦è¾¹ç•Œï¼Œå°è¯•åŠ è½½æ›´å¤šå†å²æ•°æ®...');
                                this.loadMoreHistoricalData();
                            }
                            newViewStart = 0;
                        }

                        if (newViewStart > maxStart) {
                            newViewStart = maxStart;
                        }

                        if (newViewStart !== this.viewStartIndex) {
                            this.viewStartIndex = newViewStart;
                            // ç›´æ¥æ›´æ–°è§†å›¾ï¼Œä¸è¦è®©updateVisibleRangeè¦†ç›–viewStartIndex
                            this.updateVisibleRange(this.viewStartIndex, -1);
                            console.log(`ğŸ“Š è§†å›¾çª—å£: ${this.viewStartIndex} - ${this.viewStartIndex + this.visibleDataCount - 1} (å›ºå®š${this.visibleDataCount}æ¡)`);
                        }
                    }

                    lastX = e.clientX;
                    e.preventDefault();
                });

                const stopDragging = () => {
                    if (isDragging) {
                        isDragging = false;
                        canvas.style.cursor = 'default';
                    }
                };

                canvas.addEventListener('mouseup', stopDragging);
                canvas.addEventListener('mouseleave', stopDragging);
                window.addEventListener('mouseup', stopDragging);

                canvas.addEventListener('wheel', (e) => this.handleWheelZoom(e), { passive: false });

                const resetZoomBtn = document.createElement('button');
                resetZoomBtn.textContent = 'é‡ç½®è§†å›¾';
                resetZoomBtn.className = 'btn';
                resetZoomBtn.style.position = 'absolute';
                resetZoomBtn.style.top = '10px';
                resetZoomBtn.style.right = '10px';
                resetZoomBtn.style.zIndex = '1000';

                resetZoomBtn.addEventListener('click', () => {
                    this.resetViewToLatest();
                });

                const chartContainer = document.querySelector('.chart-container');
                chartContainer.appendChild(resetZoomBtn);

                console.log('âœ… è‡ªå®šä¹‰æ‹–æ‹½å’Œç¼©æ”¾åŠŸèƒ½å·²å¯ç”¨:');
                console.log('  - é¼ æ ‡æ‹–æ‹½: å·¦å³å¹³ç§»æ—¶é—´è½´');
                console.log('  - é¼ æ ‡æ»šè½®: ç¼©æ”¾æ—¶é—´èŒƒå›´');
                console.log('  - é‡ç½®æŒ‰é’®: è¿”å›æœ€æ–°æ•°æ®');
            }

            handleWheelZoom(event) {
                event.preventDefault();

                const fullLength = this.chart.data.fullLabels ? this.chart.data.fullLabels.length : 0;
                if (!fullLength) return;

                if (event.deltaY === 0) return;

                const direction = event.deltaY < 0 ? 'in' : 'out';
                const zoomStep = Math.max(5, Math.round(this.visibleDataCount * 0.1));
                const focusRatio = this.computeFocusRatio(event);

                if (direction === 'in' && this.visibleDataCount > 10) {
                    const newCount = Math.max(10, this.visibleDataCount - zoomStep);
                    this.adjustVisibleRange(newCount, focusRatio);
                    console.log(`ğŸ” æ”¾å¤§è§†å›¾ -> æ˜¾ç¤º ${this.visibleDataCount} æ¡æ•°æ®`);
                } else if (direction === 'out' && this.visibleDataCount < fullLength) {
                    const newCount = Math.min(fullLength, this.visibleDataCount + zoomStep);
                    this.adjustVisibleRange(newCount, focusRatio);
                    console.log(`ğŸ” ç¼©å°è§†å›¾ -> æ˜¾ç¤º ${this.visibleDataCount} æ¡æ•°æ®`);
                }
            }

            computeFocusRatio(event) {
                const canvas = this.chart.canvas;
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                if (!Number.isFinite(x) || rect.width <= 0) {
                    return 0.5;
                }
                const ratio = x / rect.width;
                return Math.min(0.95, Math.max(0.05, ratio));
            }

            adjustVisibleRange(newCount, focusRatio = 0.5) {
                const fullLength = this.chart.data.fullLabels ? this.chart.data.fullLabels.length : 0;
                if (!fullLength) return;

                const currentRange = this.visibleDataCount - 1;
                const centerIndex = this.viewStartIndex + (currentRange > 0 ? currentRange * focusRatio : 0);

                this.visibleDataCount = Math.min(Math.max(newCount, 10), fullLength);
                const maxStart = Math.max(0, fullLength - this.visibleDataCount);

                let newViewStart = Math.round(centerIndex - (this.visibleDataCount - 1) * focusRatio);
                newViewStart = Math.max(0, Math.min(maxStart, newViewStart));

                this.viewStartIndex = newViewStart;
                this.updateVisibleRange(this.viewStartIndex, -1);
            }

            resetViewToLatest() {
                const fullLength = this.chart.data.fullLabels ? this.chart.data.fullLabels.length : 0;
                if (!fullLength) return;

                this.visibleDataCount = Math.min(this.getDefaultVisibleCount(this.currentInterval), fullLength);
                const maxStart = Math.max(0, fullLength - this.visibleDataCount);
                this.viewStartIndex = maxStart;
                this.updateVisibleRange(this.viewStartIndex, -1);
                console.log(`ğŸ”„ è§†å›¾é‡ç½® -> æœ€æ–° ${this.visibleDataCount} æ¡æ•°æ®`);
            }

            isNearRightEdge() {
                const fullLength = this.chart.data.fullLabels ? this.chart.data.fullLabels.length : 0;
                if (!fullLength) return true;
                const maxStart = Math.max(0, fullLength - this.visibleDataCount);
                return this.viewStartIndex >= Math.max(0, maxStart - 2);
            }

            updateVisibleRange(startIndex, endIndex) {
                const fullLabels = this.chart.data.fullLabels;
                const allDatasets = this.chart.data.datasets;

                if (!fullLabels || fullLabels.length === 0) return;

                // ç¡®ä¿ç´¢å¼•èŒƒå›´å®‰å…¨ä¸”ä¿æŒå›ºå®šè§†çª—å¤§å°
                const safeStart = Math.max(0, Math.min(startIndex, fullLabels.length - 1));
                
                // å…³é”®ä¿®å¤ï¼šä¿æŒå›ºå®šçš„visibleDataCountï¼Œä¸è®©endIndexå½±å“çª—å£å¤§å°
                const actualVisibleCount = Math.min(this.visibleDataCount, fullLabels.length - safeStart);
                const safeEnd = safeStart + actualVisibleCount - 1;

                this.chart.data.labels = fullLabels.slice(safeStart, safeEnd + 1);
                this.dragAccumulator = 0;
                
                // æ›´æ–°æ¯ä¸ªæ•°æ®é›†çš„å¯è§éƒ¨åˆ†
                this.chart.data.datasets.forEach((dataset) => {
                    if (dataset && dataset.fullData) {
                        dataset.data = dataset.fullData.slice(safeStart, safeEnd + 1);
                    }
                    if (dataset && dataset.fullExchangePrices) {
                        dataset.exchangePrices = dataset.fullExchangePrices.slice(safeStart, safeEnd + 1);
                    }
                    if (dataset && dataset.fullBinancePrices) {
                        dataset.binancePrices = dataset.fullBinancePrices.slice(safeStart, safeEnd + 1);
                    }
                    if (dataset && dataset.fullPriceDiffs) {
                        dataset.priceDiffs = dataset.fullPriceDiffs.slice(safeStart, safeEnd + 1);
                    }
                });

                // æ ¹æ®å®é™…æ˜¾ç¤ºçš„æ•°æ®ç‚¹æ•°è°ƒæ•´Xè½´åˆ»åº¦
                if (this.chart.options?.scales?.x?.ticks) {
                    this.chart.options.scales.x.ticks.maxTicksLimit = Math.max(3, Math.min(12, Math.ceil(actualVisibleCount / 10)));
                }

                this.chart.update('none');
                
                console.log(`ğŸ¯ è§†çª—æ›´æ–°: ${safeStart} - ${safeEnd} (å›ºå®šæ˜¾ç¤º${actualVisibleCount}æ¡æ•°æ®)`);
            }
            
            bindEvents() {
                // äº¤æ˜“æ‰€å¤šé€‰åˆ‡æ¢
                document.querySelectorAll('.exchange-checkbox').forEach(label => {
                    const checkbox = label.querySelector('input[type="checkbox"]');
                    
                    label.addEventListener('click', (e) => {
                        if (this.isLoading) return;
                        e.preventDefault();
                        
                        // åˆ‡æ¢å¤é€‰æ¡†çŠ¶æ€
                        checkbox.checked = !checkbox.checked;
                        
                        // æ›´æ–°è§†è§‰æ ·å¼
                        if (checkbox.checked) {
                            label.classList.add('active');
                        } else {
                            label.classList.remove('active');
                        }
                        
                        // æ›´æ–°é€‰ä¸­çš„äº¤æ˜“æ‰€åˆ—è¡¨
                        this.updateSelectedExchanges();
                        
                        this.isViewInitialized = false;
                        this.visibleDataCount = this.getDefaultVisibleCount(this.currentInterval);
                        this.viewStartIndex = 0;
                        
                        // é‡æ–°åŠ è½½æ•°æ®
                        this.loadData();
                    });
                    
                    // ç›´æ¥ç‚¹å‡»å¤é€‰æ¡†æ—¶ä¹Ÿè¦å¤„ç†
                    checkbox.addEventListener('change', (e) => {
                        if (this.isLoading) return;
                        
                        // æ›´æ–°è§†è§‰æ ·å¼
                        if (checkbox.checked) {
                            label.classList.add('active');
                        } else {
                            label.classList.remove('active');
                        }
                        
                        // æ›´æ–°é€‰ä¸­çš„äº¤æ˜“æ‰€åˆ—è¡¨
                        this.updateSelectedExchanges();
                        
                        this.isViewInitialized = false;
                        this.visibleDataCount = this.getDefaultVisibleCount(this.currentInterval);
                        this.viewStartIndex = 0;
                        
                        // é‡æ–°åŠ è½½æ•°æ®
                        this.loadData();
                    });
                });
                
                // æ—¶é—´å‘¨æœŸåˆ‡æ¢
                document.querySelectorAll('[data-interval]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (this.isLoading) return;
                        
                        document.querySelectorAll('[data-interval]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        
                        this.currentInterval = e.target.dataset.interval;
                        this.visibleDataCount = this.getDefaultVisibleCount(this.currentInterval);
                        this.isViewInitialized = false;
                        this.viewStartIndex = 0;
                        this.loadData();
                        
                        // æ›´æ–°æ˜¾ç¤º
                        document.getElementById('currentInterval').textContent = 
                            e.target.textContent;
                    });
                });
            }
            
            updateSelectedExchanges() {
                // æ”¶é›†æ‰€æœ‰é€‰ä¸­çš„äº¤æ˜“æ‰€
                const selectedExchanges = [];
                document.querySelectorAll('.exchange-checkbox input[type="checkbox"]:checked').forEach(checkbox => {
                    selectedExchanges.push(checkbox.dataset.exchange);
                });
                
                // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªäº¤æ˜“æ‰€è¢«é€‰ä¸­
                if (selectedExchanges.length === 0) {
                    // å¦‚æœæ²¡æœ‰é€‰ä¸­ä»»ä½•äº¤æ˜“æ‰€ï¼Œé»˜è®¤é€‰ä¸­aster
                    const asterCheckbox = document.querySelector('.exchange-checkbox input[data-exchange="aster"]');
                    if (asterCheckbox) {
                        asterCheckbox.checked = true;
                        asterCheckbox.closest('.exchange-checkbox').classList.add('active');
                        selectedExchanges.push('aster');
                    }
                }
                
                this.selectedExchanges = selectedExchanges;
                
                // æ›´æ–°ä¾§è¾¹æ æ˜¾ç¤º
                document.getElementById('currentExchange').textContent = 
                    this.selectedExchanges.map(ex => ex.toUpperCase()).join(', ');
                
                console.log('é€‰ä¸­çš„äº¤æ˜“æ‰€:', this.selectedExchanges);
            }
            
            async loadData(additionalLimit = 200, isLoadingMore = false) {
                if (this.isLoading) {
                    if (isLoadingMore) {
                        console.log('â³ å†å²æ•°æ®ä»åœ¨åŠ è½½ï¼Œå¿½ç•¥é‡å¤è¯·æ±‚');
                    }
                    return;
                }

                const previousLength = this.chart?.data?.fullLabels ? this.chart.data.fullLabels.length : 0;
                const wasAtRightEdge = this.isViewInitialized ? this.isNearRightEdge() : true;

                this.isLoading = true;
                this.isLoadingMore = isLoadingMore;

                if (!isLoadingMore) {
                    this.showLoading(true);
                } else {
                    document.getElementById('lastUpdate').textContent = 'åŠ è½½å†å²æ•°æ®...';
                }

                try {
                    const exchangesParam = this.selectedExchanges.join(',');
                    const limit = isLoadingMore ? additionalLimit * 5 : additionalLimit;

                    const response = await fetch(
                        `/api/kline_data?exchanges=${exchangesParam}&interval=${this.currentInterval}&limit=${limit}`
                    );
                    const result = await response.json();

                    if (result.success && result.data) {
                        this.updateMultiChart(result.data, {
                            isLoadingMore,
                            wasAtRightEdge,
                            previousLength
                        });
                        this.updateMultiSidebar(result.data);

                        if (!isLoadingMore) {
                            document.getElementById('lastUpdate').textContent =
                                'æ›´æ–°: ' + new Date().toLocaleTimeString();
                        }

                        let totalCount = 0;
                        Object.values(result.data).forEach(exchangeData => {
                            totalCount += exchangeData.length;
                        });
                        document.getElementById('dataCount').textContent = `${totalCount} æ¡`;

                        if (isLoadingMore) {
                            console.log(`ğŸ“ˆ åŠ è½½äº†æ›´å¤šå†å²æ•°æ®ï¼Œæ€»æ•°æ®ç‚¹: ${this.chart.data.fullLabels ? this.chart.data.fullLabels.length : totalCount}`);
                        } else {
                            console.log(`âœ… æ•°æ®åˆ·æ–°å®Œæˆ: ${this.selectedExchanges.join(', ')} (${this.currentInterval})`);
                        }

                        return result.data;
                    } else {
                        throw new Error(result.error || 'æ•°æ®åŠ è½½å¤±è´¥');
                    }

                } catch (error) {
                    console.error('âŒ åŠ è½½æ•°æ®å¤±è´¥:', error);
                    if (!isLoadingMore) {
                        document.getElementById('lastUpdate').textContent = 'åŠ è½½å¤±è´¥';
                    }
                    return null;
                } finally {
                    this.isLoading = false;
                    this.isLoadingMore = false;
                    if (!isLoadingMore) {
                        this.showLoading(false);
                    }
                }
            }
            
            async loadMoreHistoricalData() {
                if (this.isLoadingMoreHistory || this.isLoading) {
                    return false;
                }

                this.isLoadingMoreHistory = true;
                console.log('ğŸ“Š å°è¯•åŠ è½½æ›´å¤šå†å²æ•°æ®...');

                try {
                    const result = await this.loadData(400, true);
                    return result !== null;
                } finally {
                    this.isLoadingMoreHistory = false;
                }
            }
            
            updateChart(klineData) {
                const labels = [];
                const data = [];
                
                // è½¬æ¢æ•°æ®
                klineData.forEach(item => {
                    const date = new Date(item.timestamp);
                    labels.push(date.toLocaleString());
                    data.push(item.close); // ä½¿ç”¨æ”¶ç›˜ä»·ä½œä¸ºä»·å·®
                });
                
                // ä¿å­˜å®Œæ•´æ•°æ®ä¾›æ‹–æ‹½ä½¿ç”¨
                const dataset = {
                    label: `${this.selectedExchanges[0].toUpperCase()} ä»·å·®`,
                    data: data,
                    fullData: data.slice(), // ä¿å­˜å®Œæ•´æ•°æ®å‰¯æœ¬
                    borderColor: this.getExchangeColor(this.selectedExchanges[0]),
                    backgroundColor: this.getExchangeColor(this.selectedExchanges[0]) + '20',
                    fill: false
                };
                
                // æ›´æ–°å›¾è¡¨
                this.chart.data.labels = labels;
                this.chart.data.datasets = [dataset];
                
                // ä¿å­˜å®Œæ•´æ ‡ç­¾ä¾›æ‹–æ‹½ä½¿ç”¨
                this.chart.data.fullLabels = labels.slice();
                
                this.chart.update('none');
                
                console.log(`å›¾è¡¨æ›´æ–°: ${labels.length} ä¸ªæ•°æ®ç‚¹`);
            }
            
            updateMultiChart(multiData, options = {}) {
                const { isLoadingMore = false, wasAtRightEdge = true, previousLength = 0, preserveView = false, targetStartIndex = null } = options;

                const allTimestamps = new Set();
                Object.values(multiData).forEach(exchangeData => {
                    exchangeData.forEach(item => {
                        if (item && item.timestamp) {
                            allTimestamps.add(item.timestamp);
                        }
                    });
                });

                const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
                const labels = sortedTimestamps.map(timestamp => new Date(timestamp).toLocaleString());

                const datasets = [];

                this.selectedExchanges.forEach(exchange => {
                    const exchangeData = multiData[exchange] || [];
                    if (exchangeData.length === 0) {
                        return;
                    }

                    const dataByTimestamp = new Map(exchangeData.map(item => [item.timestamp, item]));

                    const values = [];
                    const exchangePrices = [];
                    const binancePrices = [];
                    const priceDiffs = [];

                    sortedTimestamps.forEach(timestamp => {
                        const point = dataByTimestamp.get(timestamp);
                        if (point) {
                            const closeValue = point.close !== null && point.close !== undefined
                                ? parseFloat(point.close)
                                : null;
                            values.push(Number.isFinite(closeValue) ? closeValue : null);
                            exchangePrices.push(point.exchangePrice !== undefined ? point.exchangePrice : null);
                            binancePrices.push(point.binancePrice !== undefined ? point.binancePrice : null);
                            priceDiffs.push(point.priceDiff !== undefined ? point.priceDiff : closeValue);
                        } else {
                            values.push(null);
                            exchangePrices.push(null);
                            binancePrices.push(null);
                            priceDiffs.push(null);
                        }
                    });

                    if (!values.some(v => v !== null)) {
                        return;
                    }

                    datasets.push({
                        label: `${exchange.toUpperCase()} ä»·å·®`,
                        data: values.slice(),
                        fullData: values,
                        borderColor: this.getExchangeColor(exchange),
                        backgroundColor: this.getExchangeColor(exchange) + '20',
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 3,
                        spanGaps: true,
                        exchange,
                        exchangePrices: exchangePrices.slice(),
                        binancePrices: binancePrices.slice(),
                        priceDiffs: priceDiffs.slice(),
                        fullExchangePrices: exchangePrices,
                        fullBinancePrices: binancePrices,
                        fullPriceDiffs: priceDiffs
                    });
                });

                this.chart.data.fullLabels = labels.slice();
                this.chart.data.labels = labels.slice();
                this.chart.data.datasets = datasets;
                this.fullDataLength = labels.length;

                this.postUpdateView({
                    isLoadingMore,
                    wasAtRightEdge,
                    previousLength,
                    preserveView,
                    targetStartIndex
                });

                console.log(`å¤šäº¤æ˜“æ‰€å›¾è¡¨æ›´æ–°: ${this.selectedExchanges.join(', ')} - ${labels.length} ä¸ªæ—¶é—´ç‚¹`);
            }

            postUpdateView({ isLoadingMore, wasAtRightEdge, previousLength, preserveView = false, targetStartIndex = null }) {
                const fullLength = this.chart.data.fullLabels ? this.chart.data.fullLabels.length : 0;

                if (!fullLength) {
                    this.chart.update('none');
                    return;
                }

                if (!this.isViewInitialized) {
                    this.visibleDataCount = Math.min(this.getDefaultVisibleCount(this.currentInterval), fullLength);
                    this.viewStartIndex = Math.max(0, fullLength - this.visibleDataCount);
                    this.isViewInitialized = true;
                } else if (preserveView && targetStartIndex !== null) {
                    // é™é»˜æ›´æ–°æ¨¡å¼ï¼šä¿æŒå½“å‰è§†å›¾ä½ç½®
                    const maxStart = Math.max(0, fullLength - this.visibleDataCount);
                    this.viewStartIndex = Math.min(Math.max(0, targetStartIndex), maxStart);
                    console.log(`é™é»˜æ›´æ–°ï¼šä¿æŒè§†å›¾ä½ç½®åœ¨ ${this.viewStartIndex}`);
                } else {
                    const maxStart = Math.max(0, fullLength - this.visibleDataCount);

                    if (isLoadingMore && previousLength) {
                        const addedCount = fullLength - previousLength;
                        if (addedCount > 0) {
                            this.viewStartIndex = Math.min(maxStart, this.viewStartIndex + addedCount);
                        } else {
                            this.viewStartIndex = Math.min(this.viewStartIndex, maxStart);
                        }
                    } else if (wasAtRightEdge) {
                        this.viewStartIndex = maxStart;
                    } else {
                        this.viewStartIndex = Math.min(this.viewStartIndex, maxStart);
                    }
                }

                this.updateVisibleRange(this.viewStartIndex, -1);
                this.previousFullDataLength = fullLength;
            }
            
            updateSidebar(klineData) {
                if (klineData.length === 0) return;
                
                const latest = klineData[klineData.length - 1];
                
                const formatValue = (value) => {
                    if (value === null || value === undefined) return '--';
                    const num = parseFloat(value);
                    if (isNaN(num)) return '--';
                    const sign = num >= 0 ? '+' : '';
                    return sign + num.toFixed(4) + ' USDT';
                };
                
                const getClass = (value) => {
                    const num = parseFloat(value);
                    if (isNaN(num)) return '';
                    return num >= 0 ? 'positive' : 'negative';
                };
                
                // æ›´æ–°ä»·æ ¼ä¿¡æ¯
                document.getElementById('openPrice').textContent = formatValue(latest.open);
                document.getElementById('openPrice').className = getClass(latest.open);
                
                document.getElementById('highPrice').textContent = formatValue(latest.high);
                document.getElementById('highPrice').className = getClass(latest.high);
                
                document.getElementById('lowPrice').textContent = formatValue(latest.low);
                document.getElementById('lowPrice').className = getClass(latest.low);
                
                document.getElementById('closePrice').textContent = formatValue(latest.close);
                document.getElementById('closePrice').className = getClass(latest.close);
                
                document.getElementById('volume').textContent = latest.volume || '--';
            }
            
            updateMultiSidebar(multiData) {
                // å¯¹äºå¤šäº¤æ˜“æ‰€æ•°æ®ï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªæœ‰æ•°æ®çš„äº¤æ˜“æ‰€çš„æœ€æ–°ä¿¡æ¯
                let latest = null;
                
                for (const exchange of this.selectedExchanges) {
                    if (multiData[exchange] && multiData[exchange].length > 0) {
                        latest = multiData[exchange][multiData[exchange].length - 1];
                        break;
                    }
                }
                
                if (!latest) {
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ•°æ®ï¼Œæ¸…ç©ºæ˜¾ç¤º
                    document.getElementById('openPrice').textContent = '--';
                    document.getElementById('highPrice').textContent = '--';
                    document.getElementById('lowPrice').textContent = '--';
                    document.getElementById('closePrice').textContent = '--';
                    document.getElementById('volume').textContent = '--';
                    return;
                }
                
                const formatValue = (value) => {
                    if (value === null || value === undefined) return '--';
                    const num = parseFloat(value);
                    if (isNaN(num)) return '--';
                    const sign = num >= 0 ? '+' : '';
                    return sign + num.toFixed(4) + ' USDT';
                };
                
                const getClass = (value) => {
                    const num = parseFloat(value);
                    if (isNaN(num)) return '';
                    return num >= 0 ? 'positive' : 'negative';
                };
                
                // æ›´æ–°ä»·æ ¼ä¿¡æ¯
                document.getElementById('openPrice').textContent = formatValue(latest.open);
                document.getElementById('openPrice').className = getClass(latest.open);
                
                document.getElementById('highPrice').textContent = formatValue(latest.high);
                document.getElementById('highPrice').className = getClass(latest.high);
                
                document.getElementById('lowPrice').textContent = formatValue(latest.low);
                document.getElementById('lowPrice').className = getClass(latest.low);
                
                document.getElementById('closePrice').textContent = formatValue(latest.close);
                document.getElementById('closePrice').className = getClass(latest.close);
                
                document.getElementById('volume').textContent = latest.volume || '--';
            }
            
            async loadStatistics() {
                try {
                    const response = await fetch('/api/statistics');
                    const result = await response.json();
                    
                    if (result.success) {
                        const stats = result.data;
                        
                        document.getElementById('totalRecords').textContent = 
                            stats.total_records || '--';
                        document.getElementById('activeExchanges').textContent = 
                            stats.active_exchanges || '--';
                        document.getElementById('latestTime').textContent = 
                            stats.latest_time ? new Date(stats.latest_time).toLocaleString() : '--';
                    }
                } catch (error) {
                    console.error('ç»Ÿè®¡ä¿¡æ¯åŠ è½½å¤±è´¥:', error);
                }
            }
            
            getExchangeColor(exchange) {
                const colors = {
                    'aster': '#26a69a',
                    'lighter': '#ef5350', 
                    'edgex': '#ab47bc',
                    'binance': '#ff9800'
                };
                return colors[exchange] || '#ffffff';
            }
            
            showLoading(show) {
                document.getElementById('loading').style.display = show ? 'flex' : 'none';
            }
            
            isViewingHistoricalData() {
                // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨æŸ¥çœ‹å†å²æ•°æ®ï¼ˆä¸åœ¨æœ€æ–°æ•°æ®èŒƒå›´ï¼‰
                if (!this.chart?.data?.fullLabels || !this.isViewInitialized) {
                    return false;
                }
                
                const fullLength = this.chart.data.fullLabels.length;
                const maxStartForLatest = Math.max(0, fullLength - this.visibleDataCount);
                
                // å¦‚æœviewStartIndexæ˜æ˜¾å°äºæœ€æ–°æ•°æ®çš„èµ·å§‹ä½ç½®ï¼Œè¯´æ˜åœ¨çœ‹å†å²æ•°æ®
                return this.viewStartIndex < maxStartForLatest - 5; // 5ä¸ªæ•°æ®ç‚¹çš„ç¼“å†²
            }
            
            async silentUpdate() {
                // é™é»˜æ›´æ–°ï¼šä¿æŒå½“å‰è§†å›¾ä½ç½®ï¼Œåªæ›´æ–°æ•°æ®
                console.log('ğŸ”„ é™é»˜æ›´æ–°æ•°æ®...');
                
                try {
                    const exchangesParam = this.selectedExchanges.join(',');
                    const response = await fetch(
                        `/api/kline_data?exchanges=${exchangesParam}&interval=${this.currentInterval}&limit=300`
                    );
                    const result = await response.json();
                    
                    if (result.success && result.data) {
                        // ä¿å­˜å½“å‰è§†å›¾çŠ¶æ€
                        const currentStartIndex = this.viewStartIndex;
                        const currentVisibleCount = this.visibleDataCount;
                        
                        // æ›´æ–°æ•°æ®ä½†ä¸é‡ç½®è§†å›¾
                        this.updateMultiChart(result.data, {
                            isLoadingMore: false,
                            preserveView: true,
                            targetStartIndex: currentStartIndex,
                            targetVisibleCount: currentVisibleCount
                        });
                        
                        console.log(`âœ… é™é»˜æ›´æ–°å®Œæˆï¼Œä¿æŒè§†å›¾: ${currentStartIndex}-${currentStartIndex + currentVisibleCount}`);
                    }
                } catch (error) {
                    console.error('é™é»˜æ›´æ–°å¤±è´¥:', error);
                }
            }
            
            startAutoRefresh() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                
                // æ¯5ç§’æ™ºèƒ½åˆ·æ–°
                this.refreshInterval = setInterval(() => {
                    if (this.isViewingHistoricalData()) {
                        // ç”¨æˆ·åœ¨æŸ¥çœ‹å†å²æ•°æ®ï¼Œä½¿ç”¨é™é»˜æ›´æ–°
                        this.silentUpdate();
                    } else {
                        // ç”¨æˆ·åœ¨æŸ¥çœ‹æœ€æ–°æ•°æ®ï¼Œæ­£å¸¸æ›´æ–°
                        this.loadData();
                    }
                    this.loadStatistics();
                }, 5000);
                
                console.log('ğŸ•’ æ™ºèƒ½è‡ªåŠ¨åˆ·æ–°å·²å¯åŠ¨');
            }
            
            destroy() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                if (this.chart) {
                    this.chart.destroy();
                }
            }
        }
        
        // åˆå§‹åŒ–
        let klineManager;
        
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log('å¼€å§‹åˆå§‹åŒ–klineManager...');
                klineManager = new SimpleKLineManager();
                window.klineManager = klineManager; // æ·»åŠ åˆ°å…¨å±€ä½œç”¨åŸŸä¾¿äºè°ƒè¯•
                console.log('klineManageråˆå§‹åŒ–æˆåŠŸ');
            } catch (e) {
                console.error('klineManageråˆå§‹åŒ–å¤±è´¥:', e);
            }
        });
        
        // æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (klineManager) {
                klineManager.destroy();
            }
        });
    </script>
</body>
</html>
